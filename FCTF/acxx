#! /usr/bin/env python

import sys
from os import unlink, access, F_OK
from subprocess import Popen, PIPE
import re
import linecache

COMPILER = "g++"
OK_STATUS = 0
NO_MORE_BUGS_STATUS = 1
WRONG_STATUS = 2
verbose = 0

class Uber( object ):
	__name = "Unnamed"
	def __init__( self, name = None ):
		if ( name != None ):
			self.__name = name
		print "An instance of class " + Uber.__name__ + " named `" + self.__name + "' created."

	def __del__( self ):
		print "An instance of class " + Uber.__name__ + " named `" + self.__name + "' destroyed."

	def __repr__( self ):
		return self.__class__.__name__ + "(" + self.__name + ")"

	def name( self ):
		return ( self.__name )

	def foo( self, *argv, **keywords ):
		for arg in argv:
			print arg
		for key in keywords:
			print key + "=>" + keywords[key]

	def bar( self, first, second ):
		return ( first, second )


class Hyper( Uber ):
	def __init__( self, name = None ):
		super( Hyper, self ).__init__( name )
		print "An instance of class " + Hyper.__name__ + " named `" + super( Hyper, self ).name() + "' created."

	def __del__( self ):
		print "An instance of class " + Hyper.__name__ + " named `" + self.name() + "' destroyed."
		super( Hyper, self ).__del__()


class PebkacError(Exception):
	__message = ""
	def __init__( self, msg ):
		self.__message = msg
	def __str__( self ):
		return "PEBKAC Exception occured: " + self.__message


# Lets learn something about python programming.

def learn():
	print "Program starts here."
	a = Hyper( "core" )
	print a
	a.foo( 1, "ala", 3.14159265, first = "ox" )
	c, d = a.bar( 1, 2 )
	print c
	print d
	print "Program ends here."

def msg( str, nonl = 0 ):
	if ( verbose ):
		print str,
		if ( not nonl ):
			print ""

def has_opt( opts, short, long ):
	return ( opts.count( short ) + opts.count( long ) )

def erase_opt( opts, short, long ):
	if ( opts.count( short ) > 0 ):
		opts.remove( short )
	if ( opts.count( long ) > 0 ):
		opts.remove( long )

def get_output_path_index( opts ):
	has = 0
	output_path_index = 0
	for opt in opts:
		if ( has == 1 ):
			output_path_index += 1
			break
		if ( opt == "-o" ):
			has = 1
		output_path_index += 1
	return output_path_index

def get_input_path( opts ):
	input_path_match = re.compile( "^[\\w/\\.-]+\.acxx$" )
	input_path = ""
	for opt in opts:
		if input_path_match.match( opt ):
			input_path = opt
			break
	if ( input_path == "" ):
		raise PebkacError( "no input path found" )
	return input_path

def verify_bug( input_path, line_no ):
	line = linecache.getline( input_path, int( line_no ) )
	fail_here_match = re.compile( "\\bMUST_FAIL_HERE\\b" )
	match = fail_here_match.search( line )
	status = WRONG_STATUS
	if ( match ):
		status = OK_STATUS
	return status

def check_bug( lines, input_path ):
	no_more_bugs_match = re.compile( "^" + input_path + "(:[0-9]+)+: error: #error NO_SUCH_BUG$" )
	line_number_match = re.compile( "^" + input_path + ":([0-9]+):([0-9]+:)* +(error|required from |instantiated from)" )
	required_from_here = re.compile( "^" + input_path + ":([0-9]+):([0-9]+:)* +required from " )
	ret = WRONG_STATUS
	for line in lines:
		msg( line, 1 )
		if ( ret == WRONG_STATUS ):
			match = no_more_bugs_match.match( line )
			if ( match ):
				ret = NO_MORE_BUGS_STATUS
				break
			else:
				match = line_number_match.match( line )
				if ( match ):
					ret = verify_bug( input_path, match.group( 1 ) )
					if ( ret == WRONG_STATUS ) and required_from_here.match( line ):
						continue
					break
	return ret

def acxx( argv ):
	try:
		if ( has_opt( argv, "-h", "--help" ) ):
			print "acxx -o output/path/object.ao some/dir/source.acxx"
			print "options:"
			print "-o, --output output/path/object.ao - output path for ao files"
			print "-h, --help - this help screen"
			print "-v, --verbose - print some informational messages"
			return
		if ( not has_opt( argv, "-o", "--output" ) ):
			raise PebkacError( "Output path option required and not specified" )
		global verbose
		verbose = has_opt( argv, "-v", "--verbose" )
		erase_opt( argv, "-v", "--verbose" )
		output_path = argv[ get_output_path_index( argv ) - 1 ]
		input_path = get_input_path( sys.argv[1:] )
		msg( "source file is: " + input_path )
		msg( "output path is: " + output_path )
		if ( access( output_path, F_OK ) ):
			unlink( output_path )
		BUG_TEMPLATE = "BUG_"
		bug_status = OK_STATUS
		bug_no = 0
		lines = 0
		while ( bug_status == OK_STATUS ):
			msg( "################ processing bug no: " + str( bug_no ) + " ################" )
			msg( COMPILER + " -xc++" + " -D" + BUG_TEMPLATE + str( bug_no ) + " " + " ".join( argv ) )
			out = Popen( [ COMPILER, "-xc++", "-D" + BUG_TEMPLATE + str( bug_no ) ] + argv, stderr = PIPE ).stderr;
			lines = out.readlines()
			bug_status = check_bug( lines, input_path )
			out.close()
			bug_no += 1
		if ( access( output_path, F_OK ) ):
			unlink( output_path )
		if ( bug_status == WRONG_STATUS ):
			print >> sys.stderr, "Anti-compilation of BUG number " + str( bug_no - 1 ) + " failed!"
			print "\n".join( lines )
		else:
			f = open( output_path, 'w' )
			f.close()
	except PebkacError, e:
		print e

def main():
	acxx( sys.argv[1:] )
#	learn()

if __name__ == "__main__":
	main()
